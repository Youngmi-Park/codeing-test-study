'''
9장 최단 경로 실전문제3 - 전보
난이도: 상, 풀이시간: 60분, 시간제한: 1초, 메모리제한: 128MB, 기출 유명 알고리즘 대회

문제설명
N개 도시
X→Y, Y→X 도로가 있어야만 전보를 주고 받을 수 있다. 즉, 방향 그래프이다.
각 도시의 번호와 통로가 설치되어있는 정보가 주어질 때 
C 도시에서 출발하여 메시지를 받게되는 도시의 개수는 총 몇개이고
도시들이 모두 메시지를 받는 데 까지 걸리는 시간은 얼마인가?

입력조건
첫째 줄에 도시의 개수 N, 통로 개수 M, 메시지를 보내고자 하는 도시 C가 주어진다.
(1 <= N <= 30,000, 1 <= M <= 200,000, 1 <= C <= N )
둘쨰 줄 부터 M+1번째 줄에 걸쳐서 통로에 대한 정보 X, Y, Z가 주어진다.
특정 도시 X에서 Y로 이어지는 통로가 있고 메시지가 전달되는 시간은 Z
(1 <= X, Y <= N, 1 <= Z <= 1,000)

출력조건
C에서 보낸 메시지를 받는 도시 개수와 총 거리는 시간을 공백으로 구분하여 출력

문제풀이 아이디어
한개의 도시에서 다른 모든 도시로 가는 최단 시간을 구해야하므로 다익스트라로 풀 수 있다.
INF 즉 무한인 도시는 메시지를 받지 못하는 도시이고
최단 거리가 있는 도시는 메시지를 받은 도시이다.
'''
import heapq # 우선순위 큐 구현을 위한 heapq 라이브러리

INF = int(1e9) # 무한을 의미하는 값
n, m, c = map(int, input().split()) # 도시의 개수 N, 통로 개수 M, 메시지를 보내고자 하는 도시 C
graph = [[] for _ in range(n+1)] # 연결 정보를 저장하는 2차원 리스트
distance = [INF] * (n+1)# 최단 시간을 저장하는 1차원 리스트

# 통로개수 만큼 연결 정보를 입력 받음
for i in range(m):
  x, y, z = map(int, input().split())# 도시 x에서 y로 가는 시간 z
  graph[x].append((y, z)) # 도시와 비용 저장
  
# 다익스트라 알고리즘
def dijkstra(start):
  q = [] # 우선순위 큐
  distance[start] = 0 # 자기자신으로 가는 비용은 0
  heapq.heappush(q, (0, start)) # 비용과 노드 순서로 저장
  # 큐에 노드가 있는 동안 반복
  while q: 
    dist, node = heapq.heappop(q) # 최단 거리가 가장 짧은 노드를 꺼냄
    if distance[node] < dist: # 이미 처리된 적 있다면 갱신하지 않는다.
      continue
    for i in graph[node]: # 현재 노드에 연결된 간선을 확인
      cost = dist + i[1] # 현재 노드까지 걸리는 비용 + 연결된 간선으로 가는 비용
      if cost < distance[i[0]]: # 현재 최소 비용보다 작다면 
        distance[i[0]] = cost # 작은 값으로 갱신해줌
        heapq.heappush(q, (cost, i[0])) # 비용과 노드번호를 저장

# 다익스트라 알고리즘 수행
dijkstra(c)

# 메시지를 받는 도시개수와 총 시간 확인
city = 0 # 메시지를 받는 도시 개수
time = 0 # 걸리는 시간
for d in distance: # 최단 거리 리스트를 확인
  if d < INF:
    city += 1
    time = max(time, d) # 시간은 가장 오래걸리는 시간만큼만 소요 되므로 max로 비교해서 저장
print(f"{city-1} {time}") # 시작 노드 1개를 제외해야하므로 city-1 출력
