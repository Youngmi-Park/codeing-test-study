'''
9장 최단 경로 실전문제2 - 미래 도시
난이도: 중, 풀이시간: 40분, 시간제한: 1초, 메모리제한: 128MB

문제설명
방문 판매원 A, N개 회사
특정 회사끼리는 서로 도로를 통해 연결되어 있다. 도로는 양방향, 모든 도로는 1만큼의 시간 소요
방문 판매원 A의 현재 위치는 1번 회사이고,
1. K번 회사에서 소개팅을 할 계획이다.(커피마시는 시간은 고려하지 X)
2. X번 회사에 방문해서 물건을 판매하고자 한다.
회사 사이를 이동하게 되는 최소 시간을 계산하는 프로그램

입력조건
첫째 줄에 회사 개수 N, 경로 개수 M이 주어진다.(1<=N, M<=100)
둘쨰 줄부터 M+1번째 줄에는 연결된 두 회사의 번호가 공백으로 구분되어 주어진다.
M+2번째 줄에는 X와 K가 공백으로 구분되어 차례대로 주어진다.

출력조건
첫째 줄에 방문 판매원 A가 K번 회사를 거쳐 X번 회사로 가는 최소 이동 시간을 출력한다.
만약 X번 회사에 도달할 수 없다면 -1을 출력한다.

문제풀이 아이디어
1<=N, M<=100이므로 N의 범위가 매우 한정적이다. 따라서 플로이드 워셜 알고리즘으로 풀이가능
1에서 K를 거쳐 X로 가는 최단 거리 = 1에서 K로 가는 최단 거리 + K에서 X로 가는 최단 거리이다.
모든 회사로 가는 최단거리를 구하고 각각을 더해주면 된다.
만약 INF라면 -1을 출력한다.
'''
INF = int(1e9) # 무한을 의미하는 숫자
n, m = map(int, input().split())#  회사개수 n, 경로 개수 

# 최단 거리 정보를 저장하는 2차원 배열, nxn, 무한으로 초기화
graph = [[INF] * (n+1) for _ in range(n+1)] 
# 자기 자신까지의 거리는 0으로 변경
for i in range(1, n+1):
  graph[i][i] = 0
  
# 회사끼리 연결된 정보를 입력 받음, m개
for _ in range(m):
  a, b = map(int, input().split()) # 연결된 두 회사
  graph[a][b] = 1 # 모든 회사의 도로를 이동하는 데 걸리는 시간은 1
  graph[b][a] = 1 # 양방향 도로이므로 반대방향으로 가는 것도 1로 표시
  
x, k = map(int, input().split()) # x와 k를 입력받음 (x는 최종 도착지, k는 거쳐가는 소개팅장소)
# 플로이드 워셜 수행, O(n³)
for k in range(1, n+1):
  for a in range(1, n+1):
    for b in range(1, n+1):
      graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])# 점화식에 따라 거쳐가는 것과 기존비용을 비교하여 작은 것으로 갱신해줌
      
# A→K→X 의 최소 이동 시간 출력, 도달할 수 없으면 -1 출력
print("-1" if graph[1][k] + graph[k][x] >= INF else graph[1][k] + graph[k][x])
